#!/usr/bin/env bash
# shellcheck disable=SC2004,SC2322,SC2323
################################################################################
################################################################################
####### Get repo statistics from Org(s) ########################################
################################################################################
################################################################################

# LEGEND:
# This script will use the github API to list all repos
# and sizes for an organization(s)
# It will return an output.csv or table with the following statistics:
#
# Organization Name
# Repository Name
# If empty
# Last push
# Last commit
# Latest Commit SHA (most recent commit across all branches, with pagination for repos with >100 branches)
# Latest Committed At (timestamp of the most recent commit)
# Latest Commit Branch (branch name where the latest commit was made)
# Default Branch (default branch of the repo, or "No default branch")
# isFork
# isArchived
# Repo_Size_mb
# Total record count
# Collaborator count
# Protected branches
# PR reviews
# Milestones
# Issues
# Pull requests
# PR review comments
# Commit comments
# Issue comments
# Issue events
# Releases
# Projects
# Migration URL
# Created
#
# This will work for users on GitHub.com that are trying to figure out
# how many repos they own, and how large they are.
#
# This can be used by services to help distinguish what repos
# could be an issue, as well as help prepare for a migration
#
# PREREQS:
# You need to have the following to run this script successfully:
# - GitHub Personal Access Token with a scope of "repos" and access to the organization(s) that will be analyzed
# - Either the name of the organization to be analyzed, or a list of organizations with
#   the format provided by the Organization csv report found at [YOUR_GHE_DOMAIN]/stafftools/reports
# - jq installed on the machine running the query
#
# NOTES:
# - Repositories under 1 mb will be shown as 0mb
#

###########
# GLOBALS #
###########
SLEEP='300'                                   # Number of seconds to sleep if out of API calls
SLEEP_RETRY_COUNT='15'                        # Number of times to try to sleep before giving up
SLEEP_COUNTER='0'                             # Counter of how many times we have gone to sleep
EXISTING_FILE='0'                             # Check if a file already exists
OUTPUT="${OUTPUT_PARAM:-CSV}"                 # Output type CSV or Table
REPO_LIST_ARRAY=()                            # Array of repo names to be analyzed
GITHUB_TOKEN_TYPE=${GITHUB_TOKEN_TYPE:-user}  # Whether 'user' or 'app' PAT
VERSION="cloud"
VERSION_MAJOR="0"
VERSION_MINOR="0"
REPO_PAGE_SIZE=10
EXTRA_PAGE_SIZE=50
FIELD_CONFIG_FILE=""                          # Path to field configuration CSV file
DISABLED_FIELDS=""                            # Comma-separated list of disabled fields

################################################################################
#### Function PrintUsage #######################################################
PrintUsage()
{
  cat <<EOM
Usage: gh repo-stats [options]

Options:
     -c, --config                  : Path to field configuration CSV file (Field_Name,Should_Fetch format)
                                     If not provided, all fields are fetched
     -d, --debug                   : Enable Debug logging
     -e, --extra-page-size         : Set the pagination size for subsequent, paginated GraphQL queries; reduce if timeout occurs
                                     Default: $EXTRA_PAGE_SIZE
     -h, --help                    : Show script help
     -H, --hostname                : The GitHub hostname for the request
                                     Default: github.com
     -i, --input                   : Set path to a file with a list of organizations to scan, one per line, newline delimited
     -o, --org                     : Name of the GitHub Organization to be analyzed           
     -O, --output                  : Format of output, can either be "CSV" or "Table"
                                     Default: $OUTPUT
     -p, --repo-page-size          : Set the pagination size for the initial repository GraphQL query; reduce if timeout occurs
                                     Default: $REPO_PAGE_SIZE
                                     If a timeout occurs, reduce this value
     -r, --analyze-repo-conflicts  : Checks the Repo Name against repos in other organizations and generates a list
                                     of potential naming conflicts if those orgs are to be merged during migration
    -rl, --repo-list               : Path to a file with a list of repositories to scan, one per line, newline delimited
     -t, --token                   : Set Personal Access Token with repo scope
                                     Default: token for hostname via gh auth token
     -T, --analyze-team-conflicts  : Gathers each org's teams and checks against other orgs to generate a list of
                                     potential naming conflicts if those orgs are to be merged during migration
     -y, --token-type              : Type of Personal Access, can either be "user" or "app"
                                     Default: $GITHUB_TOKEN_TYPE

Description:
  Scans an organization or list of organizations for all repositories and gathers size statistics for each repository

Example:
  gh repo-stats -o my-org-name
  gh repo-stats -o my-org-name -H github.example.com

EOM
  exit 0
}
####################################
# Read in the parameters if passed #
####################################
PARAMS=""
while (( "$#" )); do
  case "$1" in
    -h|--help)
      PrintUsage;
      ;;
    -H|--hostname)
      export GH_HOST=$2
      shift 2
      ;;
    -c|--config)
      FIELD_CONFIG_FILE=$2
      shift 2
      ;;
    -d|--debug)
      DEBUG=true
      export GH_DEBUG=api
      shift
      ;;
    -t|--token)
      export GH_TOKEN=$2
      shift 2
      ;;
    -y|--token-type)
      GITHUB_TOKEN_TYPE=$2
      shift 2
      ;;
    -i|--input)
      INPUT_FILE_NAME=$2
      shift 2
      ;;
    -r|--analyze-repo-conflicts)
      ANALYZE_CONFLICTS=1
      shift
      ;;
    -T|--analyze-team-conflicts)
      ANALYZE_TEAMS=1
      shift
      ;;
    -p|--repo-page-size)
      REPO_PAGE_SIZE=$2
      shift 2
      ;;
    -e|--extra-page-size)
      EXTRA_PAGE_SIZE=$2
      shift 2
      ;;
    -O|--output)
      OUTPUT_PARAM=$2
      shift 2
      ;;
    -o|--org)
      ORG_NAME=$2
      shift 2
      ;;
    -rl|--repo-list)
      REPO_LIST_FILE=$2
      shift 2
      ;;
    --) # end argument parsing
      shift
      break
      ;;
    -*) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
    *) # preserve positional arguments
  PARAMS="$PARAMS $1"
  shift
  ;;
  esac
done

##################################################
# Set positional arguments in their proper place #
##################################################
eval set -- "$PARAMS"

################################################################################
############################ FUNCTIONS #########################################
################################################################################
################################################################################
################################################################################
#### Function DebugJQ ##########################################################
DebugJQ() {
  # If Debug is on, print it out...
  if [[ ${DEBUG} == true ]]; then
    echo "$1" | jq '.'
  fi
}
################################################################################
#### Function Debug ############################################################
Debug() {
  # If Debug is on, print it out...
  if [[ ${DEBUG} == true ]]; then
    echo "$1"
  fi
}
################################################################################
#### Function LoadFieldConfig ##################################################
LoadFieldConfig() {
  # Initialize - by default all fields are enabled (DISABLED_FIELDS is empty)
  DISABLED_FIELDS=""

  # If no config file specified, all fields remain enabled
  if [[ -z "${FIELD_CONFIG_FILE}" ]]; then
    Debug "No field config file specified, all fields enabled"
    return 0
  fi

  # Check if config file exists
  if [[ ! -f "${FIELD_CONFIG_FILE}" ]]; then
    echo "WARN: Field config file not found: ${FIELD_CONFIG_FILE}"
    echo "Proceeding with all fields enabled"
    return 0
  fi

  echo "Loading field configuration from: ${FIELD_CONFIG_FILE}"

  # Read the config file and build DISABLED_FIELDS list
  local line_num=0
  local enabled_count=0
  local disabled_count=0
  local repo_name_found=0
  local repo_name_enabled=0
  while IFS=',' read -r field_name should_fetch || [[ -n "$field_name" ]]; do
    ((line_num++))
    # Skip header line
    if [[ ${line_num} -eq 1 ]]; then
      continue
    fi
    
    # Trim whitespace
    field_name=$(echo "${field_name}" | tr -d '[:space:]')
    should_fetch=$(echo "${should_fetch}" | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
    
    # Skip empty lines
    if [[ -z "${field_name}" ]]; then
      continue
    fi

    # Track Repo_Name field specifically
    if [[ "${field_name}" == "Repo_Name" ]]; then
      repo_name_found=1
      if [[ "${should_fetch}" == "true" ]]; then
        repo_name_enabled=1
      fi
    fi

    # Track disabled fields
    if [[ "${should_fetch}" == "true" ]]; then
      ((enabled_count++))
      Debug "Field enabled: ${field_name}"
    elif [[ "${should_fetch}" == "false" ]]; then
      # NOTE: We wrap each disabled field name with leading and trailing commas.
      # This allows other code (e.g., IsFieldEnabled) to safely check for
      # ",field_name," in DISABLED_FIELDS without accidentally matching
      # substrings of other field names. For example, a single disabled field
      # results in DISABLED_FIELDS=",Field_Name,", which still matches
      # the lookup pattern ",Field_Name," correctly.
      DISABLED_FIELDS="${DISABLED_FIELDS},${field_name},"
      ((disabled_count++))
      Debug "Field disabled: ${field_name}"
    else
      echo "WARN: Invalid value for field ${field_name} at line ${line_num}: ${should_fetch} (expected true/false)"
    fi
  done < "${FIELD_CONFIG_FILE}"

  # Validate that Repo_Name is present and enabled when using a config file
  if [[ ${repo_name_found} -eq 0 ]]; then
    echo ""
    echo "❌ ERROR: Required field 'Repo_Name' is missing from the configuration file."
    echo "   The 'Repo_Name' field is required for proper CSV output and sorting."
    echo ""
    echo "   Please add 'Repo_Name,true' to your configuration file: ${FIELD_CONFIG_FILE}"
    exit 1
  fi

  if [[ ${repo_name_enabled} -eq 0 ]]; then
    echo ""
    echo "❌ ERROR: Required field 'Repo_Name' is disabled in the configuration file."
    echo "   The 'Repo_Name' field is required for proper CSV output and sorting."
    echo ""
    echo "   Please set 'Repo_Name' to 'true' in your configuration file: ${FIELD_CONFIG_FILE}"
    exit 1
  fi

  echo "Field configuration loaded: ${enabled_count} fields enabled, ${disabled_count} fields disabled"
}
################################################################################
#### Function IsFieldEnabled ###################################################
IsFieldEnabled() {
  local field_name="$1"
  # Check if field is in the disabled list
  if [[ "${DISABLED_FIELDS}" == *",${field_name},"* ]]; then
    return 1  # false - field is disabled
  else
    return 0  # true - field is enabled
  fi
}
################################################################################
#### Function GetAllBranchesWithLatestCommit ###################################
# Fetches all branches for a repository using pagination and updates the global
# variables LATEST_COMMIT_SHA, LATEST_COMMITTED_AT, and LATEST_COMMIT_BRANCH
# with the latest commit info (SHA, date, branch name) across ALL branches.
GetAllBranchesWithLatestCommit() {
  local owner=$1
  local repo_name=$2
  local branch_count=$3
  
  # If 100 or fewer branches, the initial GraphQL query already fetched all branches
  if [[ ${branch_count} -le 100 ]]; then
    return 0  # No extra pagination needed; ParseRepoData will use the already-fetched allBranches data
  fi
  
  Debug "Repository ${owner}/${repo_name} has ${branch_count} branches, fetching all with pagination..."
  
  local BRANCH_QUERY="query(\$owner: String!, \$name: String!, \$pageSize: Int!, \$endCursor: String) {
    repository(owner: \$owner, name: \$name) {
      refs(refPrefix: \"refs/heads/\", first: \$pageSize, after: \$endCursor) {
        pageInfo {
          endCursor
          hasNextPage
        }
        nodes {
          name
          target {
            ... on Commit {
              oid
              committedDate
            }
          }
        }
      }
    }
  }"
  
  local ALL_BRANCHES_JSON="[]"
  local HAS_NEXT_BRANCH_PAGE="true"
  local BRANCH_CURSOR=""
  
  while [[ "${HAS_NEXT_BRANCH_PAGE}" == "true" ]]; do
    local BRANCH_DATA
    if [[ -n "${BRANCH_CURSOR}" ]]; then
      BRANCH_DATA=$(gh api graphql -f query="${BRANCH_QUERY}" -F owner="${owner}" -F name="${repo_name}" -F pageSize="${EXTRA_PAGE_SIZE}" -F endCursor="${BRANCH_CURSOR}" 2>/dev/null)
    else
      BRANCH_DATA=$(gh api graphql -f query="${BRANCH_QUERY}" -F owner="${owner}" -F name="${repo_name}" -F pageSize="${EXTRA_PAGE_SIZE}" 2>/dev/null)
    fi
    
    local BRANCH_ERROR=$?
    if [[ ${BRANCH_ERROR} -ne 0 ]]; then
      Debug "Error fetching branches for ${owner}/${repo_name}, using partial data"
      break
    fi
    
    # Extract branch nodes and merge with accumulated data
    local NEW_BRANCHES
    NEW_BRANCHES=$(echo "${BRANCH_DATA}" | jq -r '.data.repository.refs.nodes')
    ALL_BRANCHES_JSON=$(echo "${ALL_BRANCHES_JSON}" "${NEW_BRANCHES}" | jq -s 'add')
    
    # Check for more pages
    HAS_NEXT_BRANCH_PAGE=$(echo "${BRANCH_DATA}" | jq -r '.data.repository.refs.pageInfo.hasNextPage')
    BRANCH_CURSOR=$(echo "${BRANCH_DATA}" | jq -r '.data.repository.refs.pageInfo.endCursor')
  done
  
  # Find the latest commit across all branches
  local LATEST
  LATEST=$(echo "${ALL_BRANCHES_JSON}" | jq -r '[.[] | select(.target.committedDate != null)] | sort_by(.target.committedDate) | reverse | .[0]')
  
  if [[ -n "${LATEST}" && "${LATEST}" != "null" ]]; then
    LATEST_COMMIT_SHA=$(echo "${LATEST}" | jq -r '.target.oid // empty')
    LATEST_COMMITTED_AT=$(echo "${LATEST}" | jq -r '.target.committedDate // empty')
    LATEST_COMMIT_BRANCH=$(echo "${LATEST}" | jq -r '.name // empty')
  fi
  
  Debug "Found latest commit across ${branch_count} branches: ${LATEST_COMMIT_SHA} on ${LATEST_COMMIT_BRANCH}"
}
################################################################################
#### Function BuildOutputRow ###################################################
BuildOutputRow() {
  # Build output row based on enabled fields
  # Uses global variables for field values
  local OUTPUT_ROW=""
  
  IsFieldEnabled "Org_Name" && OUTPUT_ROW="${OUTPUT_ROW}${ORG_NAME},"
  IsFieldEnabled "Repo_Name" && OUTPUT_ROW="${OUTPUT_ROW}${REPO_NAME},"
  if [[ "$(isCompatibleGHESVersion)" -eq "1" ]]; then
    IsFieldEnabled "Is_Empty" && OUTPUT_ROW="${OUTPUT_ROW}${IS_EMPTY},"
  fi
  IsFieldEnabled "Last_Push" && OUTPUT_ROW="${OUTPUT_ROW}${PUSHED_AT},"
  IsFieldEnabled "Last_Update" && OUTPUT_ROW="${OUTPUT_ROW}${UPDATED_AT},"
  IsFieldEnabled "Latest_Commit_SHA" && OUTPUT_ROW="${OUTPUT_ROW}${LATEST_COMMIT_SHA},"
  IsFieldEnabled "Latest_Committed_At" && OUTPUT_ROW="${OUTPUT_ROW}${LATEST_COMMITTED_AT},"
  IsFieldEnabled "Latest_Commit_Branch" && OUTPUT_ROW="${OUTPUT_ROW}${LATEST_COMMIT_BRANCH},"
  IsFieldEnabled "Default_Branch" && OUTPUT_ROW="${OUTPUT_ROW}${DEFAULT_BRANCH},"
  IsFieldEnabled "isFork" && OUTPUT_ROW="${OUTPUT_ROW}${IS_FORK},"
  IsFieldEnabled "isArchived" && OUTPUT_ROW="${OUTPUT_ROW}${IS_ARCHIVED},"
  IsFieldEnabled "Repo_Size_mb" && OUTPUT_ROW="${OUTPUT_ROW}${REPO_SIZE},"
  IsFieldEnabled "Record_Count" && OUTPUT_ROW="${OUTPUT_ROW}${RECORD_CT},"
  IsFieldEnabled "Collaborator_Count" && OUTPUT_ROW="${OUTPUT_ROW}${COLLABORATOR_CT},"
  IsFieldEnabled "Protected_Branch_Count" && OUTPUT_ROW="${OUTPUT_ROW}${PROTECTED_BRANCH_CT},"
  IsFieldEnabled "PR_Review_Count" && OUTPUT_ROW="${OUTPUT_ROW}${PR_REVIEW_CT},"
  IsFieldEnabled "Milestone_Count" && OUTPUT_ROW="${OUTPUT_ROW}${MILESTONE_CT},"
  IsFieldEnabled "Issue_Count" && OUTPUT_ROW="${OUTPUT_ROW}${ISSUE_CT},"
  IsFieldEnabled "PR_Count" && OUTPUT_ROW="${OUTPUT_ROW}${PR_CT},"
  IsFieldEnabled "PR_Review_Comment_Count" && OUTPUT_ROW="${OUTPUT_ROW}${PR_REVIEW_COMMENT_CT},"
  IsFieldEnabled "Commit_Comment_Count" && OUTPUT_ROW="${OUTPUT_ROW}${COMMIT_COMMENT_CT},"
  IsFieldEnabled "Issue_Comment_Count" && OUTPUT_ROW="${OUTPUT_ROW}${ISSUE_COMMENT_CT},"
  IsFieldEnabled "Issue_Event_Count" && OUTPUT_ROW="${OUTPUT_ROW}${ISSUE_EVENT_CT},"
  IsFieldEnabled "Release_Count" && OUTPUT_ROW="${OUTPUT_ROW}${RELEASE_CT},"
  IsFieldEnabled "Project_Count" && OUTPUT_ROW="${OUTPUT_ROW}${PROJECT_CT},"
  IsFieldEnabled "Branch_Count" && OUTPUT_ROW="${OUTPUT_ROW}${BRANCH_CT},"
  IsFieldEnabled "Tag_Count" && OUTPUT_ROW="${OUTPUT_ROW}${TAG_CT},"
  IsFieldEnabled "Discussion_Count" && OUTPUT_ROW="${OUTPUT_ROW}${DISCUSSION_CT},"
  IsFieldEnabled "Has_Wiki" && OUTPUT_ROW="${OUTPUT_ROW}${HAS_WIKI},"
  IsFieldEnabled "Full_URL" && OUTPUT_ROW="${OUTPUT_ROW}${URL},"
  IsFieldEnabled "Migration_Issue" && OUTPUT_ROW="${OUTPUT_ROW}${MIGRATION_ISSUE},"
  IsFieldEnabled "Created" && OUTPUT_ROW="${OUTPUT_ROW}${CREATED_AT},"

  # Remove trailing comma
  OUTPUT_ROW="${OUTPUT_ROW%,}"
  
  echo "${OUTPUT_ROW}"
}
################################################################################
#### Function Header ###########################################################
Header() {
  echo ""
  echo "######################################################"
  echo "######################################################"
  echo "############# GitHub repo list and sizer #############"
  echo "######################################################"
  echo "######################################################"
  echo ""

  ################################################################
  # Validate we can hit the endpoint by getting the current user #
  ################################################################
  if [[ ${GITHUB_TOKEN_TYPE} == "user" ]]; then
    USER_DATA=$(gh api user)
    ERROR_CODE=$?
  
    #######################
    # Validate the return #
    #######################
    if [ "${ERROR_CODE}" -ne 0 ]; then
      echo "Error getting user"
      echo "${USER_DATA}"
    else
      USER_LOGIN=$(echo "${USER_DATA}" | jq -r '.login')
      # Check for success
      if [[ -z ${USER_LOGIN} ]]; then
        # Got bad return
        echo "ERROR! Failed to validate GHE instance"
        echo "Received error: ${USER_DATA}"
        exit 1
      else
        Debug "Successfully validated access to GHE Instance..."
      fi
    fi
  fi

  #####################
  # Check GHE version #
  #####################
  if [[ "$(isCloud)" -eq 0  ]]; then
    META_DATA=$(gh api meta)
    ERROR_CODE=$?

    #######################
    # Validate the return #
    #######################
    if [ "${ERROR_CODE}" -ne 0 ]; then
      echo "Error getting GHE version"
      echo "${META_DATA}"
    else
      VERSION=$(echo "${META_DATA}" | jq -r '.installed_version')

      # Get major/minor versions
      VERSION_MAJOR=$(echo "${VERSION}" | cut -d "." -f 1);
      VERSION_MINOR=$(echo "${VERSION}" | cut -d "." -f 2);

      # Validate supported versions
      if [[ "$(isCompatibleGHESVersion)" -eq "0" ]]; then
        echo "GitHub Enterprise Server v${VERSION} is not supported."
        exit 1;
      else
        echo "GitHub Enterprise Server v${VERSION}"
      fi
    fi
  fi
  Debug "Version: ${VERSION}"


  ###########################
  # Check org or input file #
  ###########################
  if [[ -z ${ORG_NAME} ]] && [[ -z ${INPUT_FILE_NAME} ]]; then
    ###########################################
    # Get the name of the GitHub Organization #
    ###########################################
    echo ""
    echo "------------------------------------------------------"
    echo "Please enter name of the GitHub Organization you wish to"
    echo "gather information from, followed by [ENTER]:"
    ########################
    # Read input from user #
    ########################
    read -r ORG_NAME

    # Clean any whitespace that may be enetered
    ORG_NAME_NO_WHITESPACE="$(echo -e "${ORG_NAME}" | tr -d '[:space:]')"
    ORG_NAME="${ORG_NAME_NO_WHITESPACE}"

    #########################
    # Validate the Org Name #
    #########################
    if [ ${#ORG_NAME} -le 1 ]; then
      echo "Error! You must give a valid Organization name!"
      exit 1
    fi
  fi

  ###########################################
  # Make lower case to prevent weird issues #
  ###########################################
  ORG_NAME=$(echo "${ORG_NAME}" | tr '[:upper:]' '[:lower:]')
}
################################################################################
################################################################################
#### Function Footer ###########################################################
Footer() {
  #######################################
  # Basic footer information and totals #
  #######################################
  echo ""
  echo "######################################################"
  echo "The script has completed"
  echo ""
  if [[ ${OUTPUT} != "CSV" ]]; then
    column -t -s','  "${OUTPUT_FILE_NAME}"
    rm -f "${OUTPUT_FILE_NAME}"
  else
    echo "Results file:[${OUTPUT_FILE_NAME}]"
  fi
  echo "######################################################"
  echo ""
}
################################################################################
#### Function GenerateFiles ####################################################
GenerateFiles() {
  ##########################
  # Get current date stamp #
  ##########################
  # Get datestring YYYYMMDDHHMM
  DATE=$(date +%Y%m%d%H%M)

  ####################
  # Create File Name #
  ####################
  # Example: MyOrg-all_repos-201901041059.csv
  OUTPUT_FILE_NAME="$ORG_NAME-all_repos-$DATE.csv"

  ######################################################
  # Need to see if there is a file that already exists #
  ######################################################
  EXISTING_FILE_CMD=$(find . -name "$ORG_NAME-all_repos-*" |grep . 2>&1)

  #######################
  # Load the error code #
  #######################
  ERROR_CODE=$?

  ##############################
  # Check the shell for errors #
  ##############################
  if [ "${ERROR_CODE}" -eq 0 ]; then
    # There is already file
    # Going to use and append
    OUTPUT_FILE_NAME="${EXISTING_FILE_CMD:2}"
    EXISTING_FILE=1
  fi

  if [[ ${ANALYZE_CONFLICTS} -eq 1 ]]; then
    REPO_CONFLICTS_OUTPUT_FILE="$ORG_NAME-repo-conflicts-${DATE}.csv"

    ######################################################
    # Need to see if there is a file that already exists #
    ######################################################
    EXISTING_FILE_CMD=$(find . -name "$ORG_NAME-repo-conflicts-*" |grep . 2>&1)

    #######################
    # Load the error code #
    #######################
    ERROR_CODE=$?

    ##############################
    # Check the shell for errors #
    ##############################
    if [ "${ERROR_CODE}" -eq 0 ]; then
      # There is already file
      # Going to use and append
      REPO_CONFLICTS_OUTPUT_FILE="${EXISTING_FILE_CMD:2}"
    fi

    if ! echo "conflict qty, repo name, org names" > "${REPO_CONFLICTS_OUTPUT_FILE}"
    then
      echo "Failed to generate result file: ${REPO_CONFLICTS_OUTPUT_FILE}!"
      exit 1
    fi
  fi

  if [[ ${ANALYZE_TEAMS} -eq 1 ]]; then
    TEAM_CONFLICTS_OUTPUT_FILE="$ORG_NAME-team-conflicts-${DATE}.csv"

    ######################################################
    # Need to see if there is a file that already exists #
    ######################################################
    EXISTING_FILE_CMD=$(find . -name "$ORG_NAME-team-conflicts-*" |grep . 2>&1)

    #######################
    # Load the error code #
    #######################
    ERROR_CODE=$?

    ##############################
    # Check the shell for errors #
    ##############################
    if [ "${ERROR_CODE}" -eq 0 ]; then
      # There is already file
      # Going to use and append
      TEAM_CONFLICTS_OUTPUT_FILE="${EXISTING_FILE_CMD:2}"
    fi

    if ! echo "conflict qty, team name, org names" > "${TEAM_CONFLICTS_OUTPUT_FILE}"
    then
      echo "Failed to generate result file: ${TEAM_CONFLICTS_OUTPUT_FILE}!"
      exit 1
    fi
  fi

  #########################################
  # Only add header if were not appending #
  #########################################
  if [ "${EXISTING_FILE}" -ne 1 ]; then
    #############################
    # Create Header in the file #
    #############################
    echo "Creating file header..."

    # Build dynamic header based on enabled fields
    HEADER=""
    
    IsFieldEnabled "Org_Name" && HEADER="${HEADER}Org_Name,"
    IsFieldEnabled "Repo_Name" && HEADER="${HEADER}Repo_Name,"
    if [[ "$(isCompatibleGHESVersion)" -eq "1" ]]; then
      IsFieldEnabled "Is_Empty" && HEADER="${HEADER}Is_Empty,"
    fi
    IsFieldEnabled "Last_Push" && HEADER="${HEADER}Last_Push,"
    IsFieldEnabled "Last_Update" && HEADER="${HEADER}Last_Update,"
    IsFieldEnabled "Latest_Commit_SHA" && HEADER="${HEADER}Latest_Commit_SHA,"
    IsFieldEnabled "Latest_Committed_At" && HEADER="${HEADER}Latest_Committed_At,"
    IsFieldEnabled "Latest_Commit_Branch" && HEADER="${HEADER}Latest_Commit_Branch,"
    IsFieldEnabled "Default_Branch" && HEADER="${HEADER}Default_Branch,"
    IsFieldEnabled "isFork" && HEADER="${HEADER}isFork,"
    IsFieldEnabled "isArchived" && HEADER="${HEADER}isArchived,"
    IsFieldEnabled "Repo_Size_mb" && HEADER="${HEADER}Repo_Size_mb,"
    IsFieldEnabled "Record_Count" && HEADER="${HEADER}Record_Count,"
    IsFieldEnabled "Collaborator_Count" && HEADER="${HEADER}Collaborator_Count,"
    IsFieldEnabled "Protected_Branch_Count" && HEADER="${HEADER}Protected_Branch_Count,"
    IsFieldEnabled "PR_Review_Count" && HEADER="${HEADER}PR_Review_Count,"
    IsFieldEnabled "Milestone_Count" && HEADER="${HEADER}Milestone_Count,"
    IsFieldEnabled "Issue_Count" && HEADER="${HEADER}Issue_Count,"
    IsFieldEnabled "PR_Count" && HEADER="${HEADER}PR_Count,"
    IsFieldEnabled "PR_Review_Comment_Count" && HEADER="${HEADER}PR_Review_Comment_Count,"
    IsFieldEnabled "Commit_Comment_Count" && HEADER="${HEADER}Commit_Comment_Count,"
    IsFieldEnabled "Issue_Comment_Count" && HEADER="${HEADER}Issue_Comment_Count,"
    IsFieldEnabled "Issue_Event_Count" && HEADER="${HEADER}Issue_Event_Count,"
    IsFieldEnabled "Release_Count" && HEADER="${HEADER}Release_Count,"
    IsFieldEnabled "Project_Count" && HEADER="${HEADER}Project_Count,"
    IsFieldEnabled "Branch_Count" && HEADER="${HEADER}Branch_Count,"
    IsFieldEnabled "Tag_Count" && HEADER="${HEADER}Tag_Count,"
    IsFieldEnabled "Discussion_Count" && HEADER="${HEADER}Discussion_Count,"
    IsFieldEnabled "Has_Wiki" && HEADER="${HEADER}Has_Wiki,"
    IsFieldEnabled "Full_URL" && HEADER="${HEADER}Full_URL,"
    IsFieldEnabled "Migration_Issue" && HEADER="${HEADER}Migration_Issue,"
    IsFieldEnabled "Created" && HEADER="${HEADER}Created,"

    # Remove trailing comma
    HEADER="${HEADER%,}"

    echo "${HEADER}" >>"${OUTPUT_FILE_NAME}" 2>&1

    #######################
    # Load the error code #
    #######################
    # shellcheck disable=SC2320
    ERROR_CODE=$?

    ##############################
    # Check the shell for errors #
    ##############################
    if [ ${ERROR_CODE} -ne 0 ]; then
      echo "ERROR! Failed to write headers to file:[${OUTPUT_FILE_NAME}]!"
      exit 1
    fi
  fi
}
################################################################################
#### Function CheckAdminRights #################################################
CheckAdminRights() {

  if [[ ${GITHUB_TOKEN_TYPE} == "app" ]]; then
    echo "Skip checking user PAT admin rights for GitHub App token"
    return 0
  fi

  ################
  # Pull in vars #
  ################
  ORG_NAME="$1"

  ##################
  # Get membership #
  ##################
  MEMBERSHIP_DATA=$(gh api "orgs/${ORG_NAME}/memberships/${USER_LOGIN}")
  ERROR_CODE=$?

  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo "Error getting Membership for Org: ${ORG_NAME}"
    echo "${MEMBERSHIP_DATA}"
    exit 1
  else
    MEMBERSHIP_STATUS=$(echo "${MEMBERSHIP_DATA}" | jq -r '.role')
    MEMBERSHIP_STATUS="admin"
    if [[ ${MEMBERSHIP_STATUS} = "admin" ]]; then
      Debug "You are an owner. Getting Repo Stats"
    else
      echo "You are not an owner of org: ${ORG_NAME}"
      echo "cannot grab all needed information without access!"
      exit 1
    fi
  fi
}
################################################################################
#### Function isGHEC ###########################################################
isCloud() {
  if [[ "$OSTYPE" == "msys" ]]; then
    # If the operating system is Windows escape leading slash
    ROOT_DATA=$(gh api //)
  else
    # If the operating system is Unix-like (e.g., Linux, macOS)
    ROOT_DATA=$(gh api /)
  fi
  USER_URL=$(echo -n "${ROOT_DATA}" | jq -r '.current_user_url')

  if [[ "${USER_URL}" != "https://api.github.com/user" ]]; then
    echo 0;
  else
    echo 1;
  fi
}
################################################################################
#### Function isIncompatibleGHESVersion ########################################
isCompatibleGHESVersion() {
  if [[ "$(isCloud)" -eq 0  ]] && [[ "${VERSION_MAJOR}" -lt 3 ]]; then
    if  [[ "${VERSION_MAJOR}" -eq 2 ]] && [[ "${VERSION_MINOR}" -ge 20 ]]; then
      if [[ "${VERSION_MINOR}" -gt 21 ]]; then
        # GHES >= v2.22 (supported)
        echo 1;
      else
        # GHES v2.20 & v2.21 (no isEmpty supported)
        echo 2;
      fi
    else
      # GHES < v2.20 (not supported)
      echo 0;
    fi
  else
    # GHEC or GHES >= v3 (supported)
    echo 1;
  fi
}
################################################################################
#### Function GetOrgsFromFile ##################################################
GetOrgsFromFile() {
  # shellcheck disable=SC2034
  # Unused variables left for readability
  while IFS=, read -r login
  do
    ORG_NAME="${login}"

    echo "Checking access to org: ${ORG_NAME}"

    ######################
    # Check Admin Rights #
    ######################
    CheckAdminRights "${ORG_NAME}"
    #############################################
    # Check the API limit remaining for GraphQL #
    #############################################
    CheckAPILimit
    ######################
    # Get repos from Org #
    ######################
    GetRepos
    ######################
    # Get the teams info #
    ######################
    if [[ ${ANALYZE_TEAMS} -eq 1 ]]; then
      GetTeams
    fi
  done < "${INPUT_FILE_NAME}"
}
################################################################################
#### Function CheckAPILimit ####################################################
CheckAPILimit() {
  ##############################################################
  # Check what is remaining, and if 0, we need to sleep it off #
  ##############################################################
  API_REMAINING_REQUEST=$(gh api rate_limit)
  API_REMAINING_MESSAGE=$(echo "${API_REMAINING_REQUEST}" | jq -r '.message' 2>&1)

  if [[ "${API_REMAINING_MESSAGE}" != "Rate limiting is not enabled." ]]; then
    GRAPHQL_REMAINING=$(echo "${API_REMAINING_REQUEST}" | jq -r '.resources.graphql.remaining' 2>&1);
    CORE_REMAINING=$(echo "${API_REMAINING_REQUEST}" | jq -r '.resources.core.remaining' 2>&1);
  else
    GRAPHQL_REMAINING=9999999999
    CORE_REMAINING=9999999999
  fi

  #######################
  # Load the error code #
  #######################
  ERROR_CODE=$?

  ##############################
  # Check the shell for errors #
  ##############################
  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo  "ERROR! Failed to get valid response back from GitHub API!"
    echo "ERROR:[${GRAPHQL_REMAINING}]"
    exit 1
  fi

  ##########################################
  # Check to see if we have API calls left #
  ##########################################
  if [[ "${GRAPHQL_REMAINING}" -eq 0 ]]; then
    # Increment the sleep counter
    ((SLEEP_COUNTER++))
    # Warn the user
    echo "WARN! We have run out of GrahpQL calls and need to sleep!"
    echo "Sleeping for ${SLEEP} seconds before next check"
    # Check if we have slept enough
    if [ "${SLEEP_COUNTER}" -gt "${SLEEP_RETRY_COUNT}" ]; then
      # We have been doing this too long
      echo "ERROR! We have tried to wait for:[$SLEEP_RETRY_COUNT] attempts!"
      echo "ERROR! We only sleep for:[${SLEEP_COUNTER}] attempts!"
      echo "Bailing out!"
      exit 1
    else
      # Get some sleep...
      sleep "${SLEEP}"
    fi
  elif [[ "${GRAPHQL_REMAINING}" == 9999999999 ]]; then
    echo "API rate limiting is not enabled."
  else
    printf "Rate limits remaining: %'d GraphQL points  %'d REST calls\n" "${GRAPHQL_REMAINING}" "${CORE_REMAINING}"
  fi
}
################################################################################
#### Function GetRepos #########################################################
GetRepos() {
  # When the version is 2.21, we need to remove the isEmpty flag
  IS_EMPTY_FLAG="isEmpty";
  if [[ "$(isCompatibleGHESVersion)" -eq "2" ]]; then
    IS_EMPTY_FLAG="";
  fi

  QUERY="query(\$login: String!, \$pageSize: Int!, \$endCursor: String) {
    organization(login: \$login) {
      repositories(first: \$pageSize, after: \$endCursor, orderBy: {field: NAME, direction: ASC}) {
        totalDiskUsage
        pageInfo {
          endCursor
          hasNextPage
        }
        nodes {
          branches: refs(refPrefix:\"refs/heads/\") {
            totalCount
          }
          # Initial fetch of first 100 branches (GitHub GraphQL max page size).
          # This is intentionally hardcoded and independent of EXTRA_PAGE_SIZE;
          # if the repo has >100 branches, GetAllBranchesWithLatestCommit() will
          # paginate using EXTRA_PAGE_SIZE to fetch all remaining branches.
          allBranches: refs(refPrefix: \"refs/heads/\", first: 100) {
            nodes {
              name
              target {
                ... on Commit {
                  oid
                  committedDate
                }
              }
            }
          }
          branchProtectionRules {
            totalCount
          }
          commitComments {
            totalCount
          }
          collaborators {
            totalCount
          }
          createdAt
          diskUsage
          discussions {
            totalCount
          }
          hasWikiEnabled
          ${IS_EMPTY_FLAG}
          isFork
          isArchived
          issues(first: \$pageSize) {
            totalCount
            pageInfo {
              endCursor
              hasNextPage
            }
            nodes {
              timeline {
                totalCount
              }
              comments {
                totalCount
              }
            }
          }
          milestones {
            totalCount
          }
          name
          owner {
            login
          }
          projectsV2 {
            totalCount
          }
          pullRequests(first: \$pageSize) {
            totalCount
            pageInfo {
              endCursor
              hasNextPage
            }
            nodes {
              comments {
                totalCount
              }
              commits {
                totalCount
              }
              number
              reviews(first: \$pageSize) {
                totalCount
                pageInfo {
                  endCursor
                  hasNextPage
                }
                nodes {
                  comments {
                    totalCount
                  }
                }
              }
              timeline {
                totalCount
              }
            }
          }
          pushedAt
          defaultBranchRef {
            name
          }
          releases {
            totalCount
          }
          tags: refs(refPrefix: \"refs/tags/\") {
            totalCount
          }
          updatedAt
          url
        }
      }
    }
  }"

  Debug "Getting repos"
  if [[ -n "$REPO_NEXT_PAGE" ]]; then
    DATA_BLOCK=$(gh api graphql -f query="$QUERY" -F login="$ORG_NAME" -F pageSize="$REPO_PAGE_SIZE" -F endCursor="$REPO_NEXT_PAGE")
  else
    DATA_BLOCK=$(gh api graphql -f query="$QUERY" -F login="$ORG_NAME" -F pageSize="$REPO_PAGE_SIZE")
  fi

  ERROR_CODE=$?
  
  if [ "${ERROR_CODE}" -ne 0 ]; then
    # We are using to big of a page size, so we need to do smaller pagination
    echo "Error getting Repos for Org: ${ORG_NAME}"
    echo "--repo-page-size might need to be set to a lower value"
  else
    ERROR_MESSAGE=$(echo "${DATA_BLOCK}" | jq -r '.errors[]?')

    if [[ -n "${ERROR_MESSAGE}" ]]; then
      echo "ERROR --- Errors occurred while retrieving repos for org: ${ORG_NAME}"
      echo "${ERROR_MESSAGE}" | jq '.'
      echo "REPOS:"
      echo "${DATA_BLOCK}" | jq '.data.organization.repositories.nodes[].name'
    fi

    ##########################
    # Get the Next Page Flag #
    ##########################
    HAS_NEXT_PAGE=$(echo "${DATA_BLOCK}" | jq -r '.data.organization.repositories.pageInfo.hasNextPage')

    ##############################
    # Get the Current End Cursor #
    ##############################
    REPO_NEXT_PAGE=$(echo "${DATA_BLOCK}" | jq -r '.data.organization.repositories.pageInfo.endCursor')

    #############################################
    # Parse all the repo data out of data block #
    #############################################
    ParseRepos "${DATA_BLOCK}"

    ########################################
    # See if we need to loop for more data #
    ########################################
    if [ "${HAS_NEXT_PAGE}" == "false" ]; then
      # We have all the data, we can move on
      echo "Gathered all repositories for org: ${ORG_NAME}"
      REPO_NEXT_PAGE=""
    elif [ "${HAS_NEXT_PAGE}" == "true" ]; then
      # We need to loop through GitHub to get all repos
      Debug "More pages of repos, gathering next batch"
      #############################################
      # Check the API limit remaining for GraphQL #
      #############################################
      CheckAPILimit
      #######################################
      # Call GetRepos again with new cursor #
      #######################################
      GetRepos
    else
      # Failing to get this value means we didnt get a good response back from GitHub
      # And it could be bad input from user, not enough access, or a bad token
      # Fail out and have user validate the info
      echo ""
      echo "######################################################"
      echo "ERROR! Failed response back from GitHub on org: ${ORG_NAME}!"
      echo "Please validate your PAT, Organization, and access levels!"
      echo "######################################################"
    fi
  fi
}
################################################################################
#### Function ParseRepos #######################################################
ParseRepos() {
  ##########################
  # Pull in the data block #
  ##########################
  PARSE_DATA=$1

  REPOS=$(echo "${PARSE_DATA}" | jq -r '.data.organization.repositories.nodes')
  
  for REPO_DATA in $(echo -n "${REPOS}" | jq -r '.[] | @base64'); do
    _jq() {
    echo -n "${REPO_DATA}" | base64 --decode | jq -r "${1}"
    }

    OWNER=$(_jq '.owner.login' | tr '[:upper:]' '[:lower:]')
    REPO_NAME=$(_jq '.name' | tr '[:upper:]' '[:lower:]')

    #########################################################
    # Need to see if the user gave a repo list to filter on #
    #########################################################
    if [[ -n "${REPO_LIST_FILE}" ]]; then
      # convert REPO_NAME to lowercase
      CHECK_REPO_NAME=$(echo "${REPO_NAME}" | tr '[:upper:]' '[:lower:]')
      # Check if the repo name is in the list
      for REPO in "${REPO_LIST_ARRAY[@]}"; do
        if [[ "${REPO}" == "${CHECK_REPO_NAME}" ]]; then
          # Found a match, we can continue
          ParseRepoData "${REPO_DATA}"
        fi
      done
    else
      #################################################################
      # Need to check if this repo has already been parsed in the doc #
      #################################################################
      grep "${OWNER},${REPO_NAME}," "${OUTPUT_FILE_NAME}" >/dev/null 2>&1

      #######################
      # Load the error code #
      #######################
      ERROR_CODE=$?

      ##############################
      # Check the shell for errors #
      ##############################
      if [ ${ERROR_CODE} -eq 0 ]; then
        # Found this in the csv already
        echo "Repo:[${OWNER}/${REPO_NAME}] has previously been analyzed, moving on..."
      elif [ ${ERROR_CODE} -ne 0 ] && [[ -z "${REPO_LIST_FILE}" ]]; then
        echo "Analyzing Repo: ${REPO_NAME}"
        ParseRepoData "${REPO_DATA}"
      fi
    fi
  done
}
################################################################################
#### Function ParseRepoData ####################################################
ParseRepoData() {
  # Pull in the repos data block
  REPO_DATA=$1
  # Convert the format to JSON
  _jq() {
    echo -n "${REPO_DATA}" | base64 --decode | jq -r "${1}"
  }

  OWNER=$(_jq '.owner.login' | tr '[:upper:]' '[:lower:]')
  REPO_NAME=$(_jq '.name' | tr '[:upper:]' '[:lower:]')
  REPO_SIZE_KB=$(_jq '.diskUsage')
  REPO_SIZE=$(ConvertKBToMB "${REPO_SIZE_KB}")

  # Look for isEmpty property only if it's supported
  IS_EMPTY="";
  if [[ "$(isCompatibleGHESVersion)" -eq "1" ]]; then
    IS_EMPTY="$(_jq '.isEmpty'),"
  fi

  CREATED_AT=$(_jq '.createdAt')
  PUSHED_AT=$(_jq '.pushedAt')
  UPDATED_AT=$(_jq '.updatedAt')
  HAS_WIKI=$(_jq '.hasWikiEnabled')
  IS_FORK=$(_jq '.isFork')
  IS_ARCHIVED=$(_jq '.isArchived')
  URL=$(_jq '.url')

  MILESTONE_CT=$(_jq '.milestones.totalCount')
  COLLABORATOR_CT=$(_jq '.collaborators.totalCount')
  PR_CT=$(_jq '.pullRequests.totalCount')
  ISSUE_CT=$(_jq '.issues.totalCount')
  RELEASE_CT=$(_jq '.releases.totalCount')
  COMMIT_COMMENT_CT=$(_jq '.commitComments.totalCount')
  PROJECT_CT=$(_jq '.projects.totalCount')
  BRANCH_CT=$(_jq '.branches.totalCount')
  TAG_CT=$(_jq '.tags.totalCount')
  DISCUSSION_CT=$(_jq '.discussions.totalCount')

  #############################################
  # Get latest commit SHA and timestamp       #
  # across all branches by sorting commits    #
  #############################################
  # First, try with initially-fetched data (up to 100 branches)
  LATEST_COMMIT_DATA=$(echo -n "${REPO_DATA}" | base64 --decode | jq -r '[.allBranches.nodes[] | select(.target.committedDate != null)] | sort_by(.target.committedDate) | reverse | .[0]')
  if [[ -n "${LATEST_COMMIT_DATA}" && "${LATEST_COMMIT_DATA}" != "null" ]]; then
    LATEST_COMMIT_SHA=$(echo "${LATEST_COMMIT_DATA}" | jq -r '.target.oid // empty')
    LATEST_COMMITTED_AT=$(echo "${LATEST_COMMIT_DATA}" | jq -r '.target.committedDate // empty')
    LATEST_COMMIT_BRANCH=$(echo "${LATEST_COMMIT_DATA}" | jq -r '.name // empty')
  else
    LATEST_COMMIT_SHA=""
    LATEST_COMMITTED_AT=""
    LATEST_COMMIT_BRANCH=""
  fi
  
  # If repo has more than 100 branches, fetch all with pagination to find true latest commit
  if [[ ${BRANCH_CT} -gt 100 ]]; then
    GetAllBranchesWithLatestCommit "${OWNER}" "${REPO_NAME}" "${BRANCH_CT}"
  fi

  #############################################
  # Get default branch name                   #
  #############################################
  DEFAULT_BRANCH=$(_jq '.defaultBranchRef.name // empty')
  if [[ -z "${DEFAULT_BRANCH}" ]]; then
    DEFAULT_BRANCH="No default branch"
  fi

  if [[ "${VERSION}" == "cloud" ]]; then
    PROTECTED_BRANCH_CT=$(_jq '.branchProtectionRules.totalCount')
  else
    PROTECTED_BRANCH_CT=$(_jq '.protectedBranches.totalCount')
  fi

  ISSUE_EVENT_CT=0
  ISSUE_COMMENT_CT=0
  PR_REVIEW_CT=0
  PR_REVIEW_COMMENT_CT=0

  ##################
  # Analyze Issues #
  ##################
  if [[ $ISSUE_CT -ne 0 ]]; then
    AnalyzeIssues "${REPO_DATA}"
  fi

  #########################
  # Analyze Pull Requests #
  #########################
  if [[ $PR_CT -ne 0 ]]; then
    AnalyzePullRequests "${REPO_DATA}"
  fi

  ###########################
  # Build the output string #
  ###########################
  RECORD_CT=$((COLLABORATOR_CT + PROTECTED_BRANCH_CT + PR_REVIEW_CT + MILESTONE_CT + ISSUE_CT + PR_CT + PR_REVIEW_COMMENT_CT + COMMIT_COMMENT_CT + ISSUE_COMMENT_CT + ISSUE_EVENT_CT + RELEASE_CT + PROJECT_CT))

  ####################################
  # Get if this is a migration issue #
  ####################################
  MIGRATION_ISSUE=$(MarkMigrationIssues "${REPO_SIZE}" "${RECORD_CT}")
  if [ "${MIGRATION_ISSUE}" -eq 0 ]; then
    MIGRATION_ISSUE="TRUE"
  else
    MIGRATION_ISSUE="FALSE"
  fi
  ########################
  # Write it to the file #
  ########################
  # Remove trailing comma from IS_EMPTY if present (it's handled by BuildOutputRow)
  IS_EMPTY="${IS_EMPTY%,}"
  OUTPUT_DATA=$(BuildOutputRow)
  echo "${OUTPUT_DATA}" >>"${OUTPUT_FILE_NAME}"

  #######################
  # Load the error code #
  #######################
  # shellcheck disable=SC2320
  ERROR_CODE=$?

  ##############################
  # Check the shell for errors #
  ##############################
  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo "ERROR! Failed to write output to file:[${OUTPUT_FILE_NAME}]"
    exit 1
  fi

  ##############################
  # Check to anazyle conflicts #
  ##############################
  if [[ ${ANALYZE_CONFLICTS} -eq 1 ]]; then
    ### Check the repository name against array of all previously-processed repositories
    REPO_INDEX=-1

    for ITEM in "${!REPO_LIST[@]}"; do
      if [[ "${REPO_LIST[${ITEM}]}" = "${REPO_NAME}" ]]; then
        REPO_INDEX=${i}
      fi
    done

    ### If this is the first instance of that repository name, add it to the list and add the group name to its array
    if [[ ${REPO_INDEX} -eq -1 ]]; then
      Debug "Repo: ${REPO_NAME} is unique. Adding to the list!"
      REPO_LIST+=( "${REPO_NAME}" )
      GROUP_LIST[(( ${#REPO_LIST[@]} - 1 ))]=${ORG_NAME}
      NUMBER_OF_CONFLICTS[(( ${#REPO_LIST[@]} - 1 ))]=1
    else
      echo "Repo: ${REPO_NAME} already exists. Adding ${ORG_NAME} to the conflict list"
      GROUP_LIST[${REPO_INDEX}]+=" ${ORG_NAME}"
      (( NUMBER_OF_CONFLICTS[REPO_INDEX]++ ))
    fi
  fi
}
################################################################################
#### Function AnalyzeIssues ####################################################
AnalyzeIssues() {
  THIS_REPO=$1

  _pr_issue_jq() {
   echo -n "${THIS_REPO}" | base64 --decode | jq -r "${1}"
  }

  ISSUES=$(_pr_issue_jq '.issues.nodes')

  ##########################
  # Get the Next Page Flag #
  ##########################
  HAS_NEXT_ISSUES_PAGE=$(_pr_issue_jq '.issues.pageInfo.hasNextPage')

  ##############################
  # Get the Current End Cursor #
  ##############################
  ISSUE_NEXT_PAGE=$(_pr_issue_jq  '.issues.pageInfo.endCursor')

  for ISSUE in $(echo -n "${ISSUES}" | jq -r '.[] | @base64'); do
    _issue_jq() {
      echo -n "${ISSUE}" | base64 --decode | jq -r "${1}"
    }

    EVENT_CT=$(_issue_jq '.timeline.totalCount')
    COMMENT_CT=$(_issue_jq '.comments.totalCount')
    ISSUE_EVENT_CT=$((ISSUE_EVENT_CT + EVENT_CT - COMMENT_CT))
    ISSUE_COMMENT_CT=$((ISSUE_COMMENT_CT + COMMENT_CT))
  done

  ########################################
  # See if we need to loop for more data #
  ########################################
  if [ "$HAS_NEXT_ISSUES_PAGE" == "false" ]; then
    # We have all the data, we can move on
    Debug "Gathered all issues from Repo: ${REPO_NAME}"
    ISSUE_NEXT_PAGE=""
  elif [ "$HAS_NEXT_ISSUES_PAGE" == "true" ]; then
    # We need to loop through GitHub to get all repos
    Debug "More pages of issues, gathering next batch"

    ######################################
    # Call GetNextIssues with new cursor #
    ######################################
    GetNextIssues
  else
    # Failing to get this value means we didnt get a good response back from GitHub
    # And it could be bad input from user, not enough access, or a bad token
    # Fail out and have user validate the info
    echo ""
    echo "######################################################"
    echo "ERROR! Failed response back from GitHub!"
    echo "Please validate your PAT, Organization, and access levels!"
    echo "######################################################"
    exit 1
  fi
}
################################################################################
#### Function GetNextIssues ####################################################
GetNextIssues() {

  QUERY="query(\$owner: String!, \$name: String!, \$pageSize: Int!, \$endCursor: String) {
    repository(owner: \$owner, name: \$name) {
      owner {
        login
      }
      name
      issues(first: \$pageSize, after: \$endCursor) {
        totalCount
        pageInfo {
          hasNextPage
          endCursor
        }
        nodes {
          timeline {
            totalCount
          }
          comments {
            totalCount
          }
        }
      }
    }
  }"

  if [[ -n "$ISSUE_NEXT_PAGE" ]]; then
    ISSUE_DATA=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F name="$REPO_NAME" -F pageSize="$EXTRA_PAGE_SIZE" -F endCursor="$ISSUE_NEXT_PAGE")
  else
    ISSUE_DATA=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F name="$REPO_NAME" -F pageSize="$EXTRA_PAGE_SIZE")
  fi

  ERROR_CODE=$?

  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo "Error getting more Issues for Repo: ${OWNER}/${REPO_NAME}"
    echo "--extra-page-size might need to be set to a lower value"
  else
    ERROR_MESSAGE=$(echo "${ISSUE_DATA}" | jq -r '.errors[]?')

    if [[ -n "${ERROR_MESSAGE}" ]]; then
      echo "ERROR --- Errors occurred while retrieving issues for repo: ${REPO_NAME}"
      echo "${ERROR_MESSAGE}" | jq '.'
    fi
    
    ISSUE_REPO=$(echo -n "${ISSUE_DATA}" | jq -r '.data.repository | @base64')

    ######################
    # Analyze the issues #
    ######################
    AnalyzeIssues "${ISSUE_REPO}"
  fi
}
################################################################################
#### Function AnalyzePullRequests ##############################################
AnalyzePullRequests() {
  PR_REPO=$1
  _pr_repo_jq() {
   echo -n "${PR_REPO}" | base64 --decode | jq -r "${1}"
  }

  Debug "Analyzing Pull Requests for: ${REPO_NAME}"

  PRS=$(_pr_repo_jq '.pullRequests.nodes')

  ##########################
  # Get the Next Page Flag #
  ##########################
  HAS_NEXT_PRS_PAGE=$(_pr_repo_jq '.pullRequests.pageInfo.hasNextPage')

  ##############################
  # Get the Current End Cursor #
  ##############################
  PR_NEXT_PAGE=$(_pr_repo_jq  '.pullRequests.pageInfo.endCursor')
  for PR in $(echo -n "${PRS}" | jq -r '.[] | @base64'); do
    _pr_jq() {
    echo -n "${PR}" | base64 --decode | jq -r "${1}"
    }

    PR_NUMBER=$(_pr_jq '.number')

    EVENT_CT=$(_pr_jq '.timeline.totalCount')
    COMMENT_CT=$(_pr_jq '.comments.totalCount')
    REVIEW_CT=$(_pr_jq '.reviews.totalCount')
    COMMIT_CT=$(_pr_jq '.commits.totalCount')

    if [[ ${REVIEW_CT} -ne 0 ]]; then
      AnalyzeReviews "${PR}"
    fi

    # TODO: Is there a possible issue with .timeline.totalCount not including all comments either?
    if [[ ${COMMIT_CT} -gt 250 ]]; then
      REDUNDANT_EVENT_CT=$((COMMENT_CT + 250))
    else
      REDUNDANT_EVENT_CT=$((COMMENT_CT + COMMIT_CT))
    fi

    if [[ ${REDUNDANT_EVENT_CT} -gt ${EVENT_CT} ]]; then
      echo ""
      echo "######################################################"
      echo "WARNING! There are more redundant events than timeline events for PR ${PR_NUMBER}!"
      echo "gh-repo-stats may have an issue"
      echo "EVENT_CT: ${EVENT_CT}"
      echo "COMMENT_CT: ${COMMENT_CT}"
      echo "COMMIT_CT: ${COMMIT_CT}"
      echo "######################################################"
    fi

    ISSUE_EVENT_CT=$((ISSUE_EVENT_CT + EVENT_CT - REDUNDANT_EVENT_CT))
    ISSUE_COMMENT_CT=$((ISSUE_COMMENT_CT + COMMENT_CT))
    PR_REVIEW_CT=$((PR_REVIEW_CT + REVIEW_CT))
  done

  ########################################
  # See if we need to loop for more data #
  ########################################
  if [ "${HAS_NEXT_PRS_PAGE}" == "false" ]; then
    # We have all the data, we can move on
    Debug "Gathered all pull requests from Repo: ${REPO_NAME}"
    PR_NEXT_PAGE=""
  elif [ "$HAS_NEXT_PRS_PAGE" == "true" ]; then
    # We need to loop through GitHub to get all pull requests
    Debug "More pages of pull requests, gathering next batch"

    #########################
    # Get the pull requests #
    #########################
    GetNextPullRequests
  else
    # Failing to get this value means we didnt get a good response back from GitHub
    # And it could be bad input from user, not enough access, or a bad token
    # Fail out and have user validate the info
    echo ""
    echo "######################################################"
    echo "ERROR! Failed response back from GitHub!"
    echo "Please validate your PAT, Organization, and access levels!"
    echo "######################################################"
    exit 1
  fi
}
################################################################################
#### Function GetNextPullRequests ##############################################
GetNextPullRequests() {

  QUERY="query(\$owner: String!, \$name: String!, \$pageSize: Int!, \$endCursor: String) {
    repository(owner: \$owner, name: \$name) {
      owner {
        login
      }
      name
      pullRequests(first: \$pageSize, after: \$endCursor) {
        totalCount
        pageInfo {
          hasNextPage
          endCursor
        }
        nodes {
          number
          commits {
            totalCount
          }
          timeline {
            totalCount
          }
          comments {
            totalCount
          }
          reviews(first: \$pageSize) {
            totalCount
            pageInfo {
              hasNextPage
              endCursor
            }
            nodes {
              comments {
                totalCount
              }
            }
          }
        }
      }
    }
  }"

  Debug "Getting pull requests"
  if [[ -n "$PR_NEXT_PAGE" ]]; then
    PR_DATA=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F name="$REPO_NAME" -F pageSize="$EXTRA_PAGE_SIZE" -F endCursor="$PR_NEXT_PAGE")
  else
    PR_DATA=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F name="$REPO_NAME" -F pageSize="$EXTRA_PAGE_SIZE")
  fi

  ERROR_CODE=$?

  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo "Error getting more Pull Requests for Repo: ${OWNER}/${REPO_NAME}"
    echo "${PR_DATA}"
  else
    ERROR_MESSAGE=$(echo "${PR_DATA}" | jq -r '.errors[]?')

    if [[ -n "${ERROR_MESSAGE}" ]]; then
      echo "ERROR --- Errors occurred while retrieving pull requests for repo: ${REPO_NAME}"
      echo "${ERROR_MESSAGE}" | jq '.'
    fi

    PR_REPO=$(echo -n "${PR_DATA}" | jq -r '.data.repository | @base64')

    AnalyzePullRequests "${PR_REPO}"
  fi
}
################################################################################
#### Function AnalyzeReviews ###################################################
AnalyzeReviews() {
  REVIEW_PR=$1

  _review_jq() {
   echo -n "${REVIEW_PR}" | base64 --decode | jq -r "${1}"
  }

  REVIEWS=$(_review_jq '.reviews.nodes')

  ##########################
  # Get the Next Page Flag #
  ##########################
  HAS_NEXT_REVIEWS_PAGE=$(_review_jq '.reviews.pageInfo.hasNextPage')

  ##############################
  # Get the Current End Cursor #
  ##############################
  REVIEW_NEXT_PAGE=$(_review_jq  '.reviews.pageInfo.endCursor')
  PR_NUMBER=$(_review_jq '.number')

  Debug "Analyzing Pull Request Reviews for: ${REPO_NAME} PR: ${PR_NUMBER}"

  for REVIEW in $(echo -n "${REVIEWS}" | jq -r '.[] | @base64'); do
    _pr_jq() {
 echo -n "${REVIEW}" | base64 --decode | jq -r "${1}"
    }

    REVIEW_COMMENT_CT=$(_pr_jq '.comments.totalCount')

    PR_REVIEW_COMMENT_CT=$((PR_REVIEW_COMMENT_CT + REVIEW_COMMENT_CT))
  done

  ########################################
  # See if we need to loop for more data #
  ########################################
  if [ "${HAS_NEXT_REVIEWS_PAGE}" == "false" ]; then
    # We have all the data, we can move on
    Debug "Gathered all reviews from PR"
    REVIEW_NEXT_PAGE=""
  elif [ "${HAS_NEXT_REVIEWS_PAGE}" == "true" ]; then
    # We need to loop through GitHub to get all pull requests
    Debug "More pages of reviews. Gathering next batch."

    #######################################
    # Call GetNextReviews with new cursor #
    #######################################
    GetNextReviews
  else
    # Failing to get this value means we didnt get a good response back from GitHub
    # And it could be bad input from user, not enough access, or a bad token
    # Fail out and have user validate the info
    echo ""
    echo "######################################################"
    echo "ERROR! Failed response back from GitHub!"
    echo "Please validate your PAT, Organization, and access levels!"
    echo "######################################################"
    exit 1
  fi
}
################################################################################
#### Function GetNextReviews ###################################################
GetNextReviews() {

  QUERY="query(\$owner: String!, \$name: String!, \$number: Int!, \$pageSize: Int!, \$endCursor: String) {
    repository(owner: \$owner, name: \$name) {
      owner {
        login
      }
      name
      pullRequest(number: \$number) {
        number
        commits {
          totalCount
        }
        timeline {
          totalCount
        }
        comments {
          totalCount
        }
        reviews(first: \$pageSize, after: \$endCursor) {
          totalCount
          pageInfo {
            hasNextPage
            endCursor
          }
          nodes {
            comments {
              totalCount
            }
          }
        }
      }
    }
  }"

  Debug "Getting pull request reviews"
  if [[ -n "$REVIEW_NEXT_PAGE" ]]; then
    REVIEW_DATA=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F name="$REPO_NAME" -F number="$PR_NUMBER" -F pageSize="$EXTRA_PAGE_SIZE" -F endCursor="$REVIEW_NEXT_PAGE")
  else
    REVIEW_DATA=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F name="$REPO_NAME" -F number="$PR_NUMBER" -F pageSize="$EXTRA_PAGE_SIZE")
  fi

  ERROR_CODE=$?

  ######################
  # Look for PR errors #
  ######################
  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo "Error getting more PR Reviews for Repo: ${OWNER}/${REPO_NAME} and PR: ${PR_NUMBER}"
    echo "${REVIEW_DATA}"
  else
    ##################
    # Get any errors #
    ##################
    ERROR_MESSAGE=$(echo "${REVIEW_DATA}" | jq -r '.errors[]?')

    ####################
    # Check for errors #
    ####################
    if [[ -n "${ERROR_MESSAGE}" ]]; then
      echo "ERROR --- Errors occurred while retrieving pr reviews for repo: ${REPO_NAME} and pr: ${PR_NUMBER}"
      echo "${ERROR_MESSAGE}" | jq '.'
    fi

    #####################
    # Get the Review PR #
    #####################
    REVIEW_PR=$(echo -n "${REVIEW_DATA}" | jq -r '.data.repository.pullRequest | @base64')

    ######################
    # Analyze the review #
    ######################
    AnalyzeReviews "${REVIEW_PR}"
  fi
}
################################################################################
#### Function GetTeams #########################################################
GetTeams() {

  QUERY="query(\$owner: String!, \$pageSize: Int!, \$endCursor: String) {
    organization(login: \$owner) {
      teams(first: \$pageSize, after: \$endCursor) {
        pageInfo {
          hasNextPage
          endCursor
        }
        nodes {
          slug
        }
      }
    }
  }"

  if [[ -n "$TEAM_NEXT_PAGE" ]]; then
    TEAM_DATA=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F pageSize="$REPO_PAGE_SIZE" -F endCursor="$TEAM_NEXT_PAGE")
  else
    TEAM_DATA=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F pageSize="$REPO_PAGE_SIZE")
  fi

  ERROR_CODE=$?

  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo "Error getting Teams for Org: ${OWNER}"
    echo "${TEAM_DATA}"
  else
    ERROR_MESSAGE=$(echo "$TEAM_DATA" | jq -r '.errors[]?')

    if [[ -n "${ERROR_MESSAGE}" ]]; then
      echo "ERROR --- Errors occurred while retrieving teams for org: ${OWNER}"
      echo "${ERROR_MESSAGE}" | jq '.'
    fi

    TEAMS=$(echo "${TEAM_DATA}" | jq '.data.organization.teams.nodes')


    ##########################
    # Get the Next Page Flag #
    ##########################
    HAS_NEXT_TEAM_PAGE=$(echo "${TEAM_DATA}" | jq -r '.data.organization.teams.pageInfo.hasNextPage')

    ##############################
    # Get the Current End Cursor #
    ##############################
    TEAM_NEXT_PAGE=$(echo "${TEAM_DATA}" | jq -r '.data.organization.teams.pageInfo.endCursor')
    
    for TEAM in $(echo -n "${TEAMS}" | jq -r '.[] | @base64'); do
      _team_jq() {
        echo -n "${TEAM}" | base64 --decode | jq -r "${1}"
      }

      TEAM_NAME=$(_team_jq '.slug')

      ### Check the team name against array of all previously-processed teams
      TEAM_INDEX=-1

      for i in "${!TEAM_LIST[@]}"; do
      if [[ "${TEAM_LIST[$i]}" = "${TEAM_NAME}" ]]; then
        TEAM_INDEX=${i}
      fi
      done

      ### If this is the first instance of that team name, add it to the list and add the org name to its array
      if [[ ${TEAM_INDEX} -eq -1 ]]; then
        Debug "Team: ${TEAM_NAME} is unique. Adding to the list!"
        TEAM_LIST+=( "${TEAM_NAME}" )
        TEAM_ORG_LIST[(( ${#TEAM_LIST[@]} - 1 ))]=${ORG_NAME}
        NUMBER_OF_TEAM_CONFLICTS[(( ${#TEAM_LIST[@]} - 1 ))]=1
      else
        Debug "Team: $TEAM_NAME already exists. Adding ${ORG_NAME} to the conflict list"
        TEAM_ORG_LIST[${TEAM_INDEX}]+=" ${ORG_NAME}"
        (( NUMBER_OF_TEAM_CONFLICTS[TEAM_INDEX]++ ))
      fi
    done

    ########################################
    # See if we need to loop for more data #
    ########################################
    if [ "${HAS_NEXT_TEAM_PAGE}" == "false" ]; then
      # We have all the data, we can move on
      Debug "Gathered all teams from PR"
      TEAM_NEXT_PAGE=""
    elif [ "${HAS_NEXT_TEAM_PAGE}" == "true" ]; then
      # We need to loop through GitHub to get all teams
      Debug "More pages of teams. Gathering next batch."

      #######################################
      # Call GetTeams with new cursor #
      #######################################
      GetTeams
    else
      # Failing to get this value means we didnt get a good response back from GitHub
      # And it could be bad input from user, not enough access, or a bad token
      # Fail out and have user validate the info
      echo ""
      echo "######################################################"
      echo "ERROR! Failed response back from GitHub!"
      echo "Please validate your PAT, Organization, and access levels!"
      echo "######################################################"
      exit 1
    fi
  fi
}
################################################################################
#### Function MarkMigrationIssues ##############################################
MarkMigrationIssues() {
  # Need to read the output files, and total the issues and see
  # if over 60k objects or repo is over 2gb

  ##############
  # Read Input #
  ##############
  REPO_SIZE="$1"
  RECORD_COUNT="$2"

  # Check if more than 60k objects
  if [ "${RECORD_COUNT}" -ge 60000 ] || [ "${REPO_SIZE}" -gt 1500 ]; then
    echo "0"
    return 0
  else
    echo "1"
    return 1
  fi
}
################################################################################
#### Function ReportConflicts ##################################################
ReportConflicts() {
  if [[ ${ANALYZE_CONFLICTS} -eq 1 ]]; then
    for (( i=0; i<${#REPO_LIST[@]}; i++)) do
      if (( ${NUMBER_OF_CONFLICTS[$i]} > 1 )); then
        echo "${NUMBER_OF_CONFLICTS[$i]},${REPO_LIST[$i]},${GROUP_LIST[$i]}" >> "${REPO_CONFLICTS_OUTPUT_FILE}"
      fi
    done
  fi

  ##########################
  # Check to analyze teams #
  ##########################
  if [[ ${ANALYZE_TEAMS} -eq 1 ]]; then
    for (( i=0; i<${#TEAM_LIST[@]}; i++)) do
      if (( ${NUMBER_OF_TEAM_CONFLICTS[$i]} > 1 )); then
        echo "${NUMBER_OF_TEAM_CONFLICTS[$i]},${TEAM_LIST[$i]},${TEAM_ORG_LIST[$i]}" >> "${TEAM_CONFLICTS_OUTPUT_FILE}"
      fi
    done
  fi
}
################################################################################
#### Function ConvertKBToMB ####################################################
ConvertKBToMB() {
  ####################################
  # Value that needs to be converted #
  ####################################
  VALUE=$1

  ##############################
  # Validate that its a number #
  ##############################
  REGEX='^[0-9]+$'
  if ! [[ ${VALUE} =~ ${REGEX} ]] ; then
    echo "ERROR! Not a number:[${VALUE}]"
    exit 1
  fi

  #################
  # Convert to MB #
  #################
  SIZEINMB=$((VALUE/1024))
  echo "${SIZEINMB}"

  ####################
  # Return the value #
  ####################
  return ${SIZEINMB}
}
################################################################################
#### Function ValidateJQ #######################################################
ValidateJQ() {
  # Need to validate the machine has jq installed as we use it to do the parsing
  # of all the json returns from GitHub

  if ! jq --version &>/dev/null
  then
    echo "Failed to find jq in the path!"
    echo "If this is a Mac, run command: brew install jq"
    echo "If this is Debian, run command: sudo apt install jq"
    echo "If this is Centos, run command: yum install jq"
    echo "Once installed, please run this script again."
    exit 1
  fi
}
################################################################################
#### Function ValidateInput ####################################################
################################################################################
ValidateInput() {
  # Check if REPO_LIST_FILE is empty
  if [[ -n "${REPO_LIST_FILE}" ]]; then
    echo "User provided a repo list file. Mapping contents..."
    # Put the contents of the file into an array seperated by newlines
    IFS=$'\n' read -d '' -r -a REPO_LIST_ARRAY < "${REPO_LIST_FILE}"
    # Make all contents of the array lowercase
    for i in "${!REPO_LIST_ARRAY[@]}"; do
      REPO_LIST_ARRAY[$i]=$(echo "${REPO_LIST_ARRAY[$i]}" | tr '[:upper:]' '[:lower:]')
    done
  fi
}
################################################################################
############################## MAIN ############################################
################################################################################

##########
# Header #
##########
Header

###########################
# Load Field Config       #
###########################
LoadFieldConfig

#########################
# Validate JQ installed #
#########################
ValidateJQ

#################
# Generate File #
#################
GenerateFiles

######################
# Validate the input #
######################
ValidateInput

########################
# Check the input file #
########################
if [[ -z ${INPUT_FILE_NAME} ]]; then
  ######################
  # Check Admin Rights #
  ######################
  CheckAdminRights "${ORG_NAME}"
  ###################
  # Get GitHub Data #
  ###################
  echo "------------------------------------------------------"
  echo "Getting repositories for org: ${ORG_NAME}"
  #############################################
  # Check the API limit remaining for GraphQL #
  #############################################
  CheckAPILimit
  #############
  # Get Repos #
  #############
  GetRepos
else
  ############
  # Get Orgs #
  ############
  GetOrgsFromFile
fi

########################
# Report all conflicts #
########################
ReportConflicts

##########
# Footer #
##########
Footer
